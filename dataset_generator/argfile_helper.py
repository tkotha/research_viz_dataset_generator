import os
import sys
import math
import pprint
import json
from helper import *

#the func-list is a list of functions that will be generated by the program
#it has the basic form of a list of pairs of string name, and dictionary
#like so:

'''
	func-list: [
			["noise", "noise-file-name.txt" or "", {"amplitude" : 1}],
			("empty", {}),
			("noise", {"amplitude" : 2}),
			("gauss2d", {"amplitude": 1, "stdvec": [1.0, 2.0], "position": [1.0, 3.0]})
			("combo" , {"list" : "filename1.txt, filename2.txt, ..."}) #... in the actual function, these will get parsed into CSV string values to load the files in question 
			#etc...
	]

	reeb-list: [
		["reebfilename1.txt", "func1.txt"]
		#etc...
	]

'''

#helper function for resolving function parameters
#THIS IS A BANDAID SOLUTION, WE WILL MOST LIKELY REVISE THIS LATER
# positionGauss::
# repeat = 2
# isRandomPerTrial = True
# isVertRandom = True
# APrimeDist = .15
# APrimeDistInc = .05
# desiredSNR = 5.0
# numOfFeaturesRange = 2, 2
# fixedScale = 1.0
# fixedStdVec = 1.0, 1.0, 1.0
# noiseType = perlin
# epsilon = .1
def resolveParameter_Unsafe(arg, value):
	if arg in ["stdvec", "position", "fixedStdVec", "APrimeDistRange"]:
		return parseFloatVector(value)
	if arg in ["numOfFeaturesRange"]:
		return parseIntVector(value)
	elif arg in ["contour_grouping_epsilon", "epsilon", "amplitude", "desiredSNR", "APrimeDist", "APrimeDistInc", "fixedScale", "fixedAmplitude"]:
		return float(value)
	elif arg in ["grouping_strategy", "repeat",  "numOfFeatures"]:
		return int(value)
	elif arg in ["isRandomPerTrial", "isVertRandom"]:
		return parseBoolAffirmative(value)
	else:
		#this means we dont know what to do with it, so its returned as its original string form
		return value


#we also need to expand the file arg system to also handle reeb graph interactions



# (any and all reeb graphs made will be auto-generating a corresponding cp_pair file as well)
def parseArgFile(argfile, path):
	fileargs = {"model" : {"obj" : "", "conn" : "", "geo": ""},
			"high-res-model": {"obj" : ""},
			"path":"",
			"func-files": [],
			"func-list" : [],
			"reeb-list" : [],
			"copy-folder": "",
			"validation-error" : False,
			"error-reason" : "",
			"generate-reeb-list-if-not-specified": True
		}
	currentArgGroup = ""
	ArgGroupDelimiter = ":::"
	SubArgGroupDelimiter = "::"
	currentSubArgGroup = ""
	FuncAssignmentDelimiter = "="
	PairingDelimiter = "::"
	

	def parseArgs(textline, argGroup = ""):
		global currentArgGroup, currentSubArgGroup
		if argGroup == "":
			#we don't do anything, so just return
			return
		if argGroup == "high-res-model":
			keyvalue = textline.split(PairingDelimiter)
			if len(keyvalue) != 2:
				fileargs["error-reason"]="error in "+argfile+", invalid argument pairing in the model specifier! QUIT"
				fileargs["validation-error"] = True
				return

			keyvalue[0] = keyvalue[0].strip()
			# print(keyvalue[0])
			keyvalue[1] = keyvalue[1].strip()
			if keyvalue[0] != "obj":
				fileargs["error-reason"]="error in "+argfile+", unrecognized high res model format, only use obj! QUIT"
				fileargs["validation-error"] = True
				return
			checkpath = determineAbsOrRelativePath(keyvalue[1], path)
			if os.path.isfile(checkpath):
				fileargs["high-res-model"]["obj"] = keyvalue[1]
			else:
				fileargs["validation-error"] = True
				fileargs["error-reason"] = "error in "+argfile+", path does not exist: "+keyvalue[1]+"! QUIT"
				return
			return
		if argGroup == "model":
			#here we dont worry about the xor relation of obj and conn-geo
			#that is taken care of during validation check
			keyvalue = textline.split(PairingDelimiter)
			if len(keyvalue) != 2:
				fileargs["error-reason"]="error in "+argfile+", invalid argument pairing in the model specifier! QUIT"
				fileargs["validation-error"] = True
				return
			
			keyvalue[0] = keyvalue[0].strip()
			keyvalue[1] = keyvalue[1].strip()
			if keyvalue[0] not in ["obj", "conn", "geo"]:
				fileargs["error-reason"]="error in "+argfile+", unrecognized model format, only use obj, or conn+geo! QUIT"
				fileargs["validation-error"] = True
				return
			checkpath = determineAbsOrRelativePath(keyvalue[1],path)
			if os.path.isfile(checkpath):
				fileargs["model"][keyvalue[0]] = keyvalue[1]
			else:
				fileargs["validation-error"] = True
				fileargs["error-reason"] = "error in "+argfile+", path does not exist: "+keyvalue[1]+"! QUIT"
				return
			return
		if argGroup == "func-files":
			#verify that each item exists, and only if it does add it to the list
			checkpath = determineAbsOrRelativePath(textline,path)
			if os.path.isfile(checkpath):
				fileargs["func-files"].append(textline)
			else:
				fileargs["validation-error"] = True
				fileargs["error-reason"] = "error in "+argfile+", function file path does not exist: "+textline+"! QUIT"
				return
		if argGroup == "copy-folder":
			checkpath = determineAbsOrRelativePath(textline, path)
			if os.path.isdir(checkpath):
				fileargs["copy-folder"] = textline
			else:
				fileargs["validation-error"] = True
				fileargs["error-reason"] = "error in "+argfile+", copy file path does not exist: "+textline+"! QUIT"
				return
		if argGroup == "func-list":
			if textline.endswith(SubArgGroupDelimiter):
				#just assign the current function we're working on
				# note, because this is a specification list, we can always be sure
				# that all assignment ops only affect the last entry of the func list
				currentSubArgGroup = textline[:-len(SubArgGroupDelimiter)]
				#make sure to increment the func count to keep funcnames in 1-based order
				#now make sure to append a new element group to the func-list
				func_count = len(fileargs["func-list"])
				fileargs["func-list"].append([currentSubArgGroup, currentSubArgGroup+"_"+str(func_count+1)+".txt",dict()])
				
			else:
				#now we assume we're dealing with an assignment op
				keyvalue = textline.split(FuncAssignmentDelimiter)
				if len(keyvalue) != 2:
					fileargs["error-reason"]="error in "+argfile+", invalid assignment in the "+currentSubArgGroup+" specifier! QUIT"
					fileargs["validation-error"] = True
					return

				keyvalue[0] = keyvalue[0].strip()
				keyvalue[1] = keyvalue[1].strip()
				#first we should check against known keywords, such as filename
				if keyvalue[0] == "filename":
					#we wont verify files here, only when they are generated should we do so
					func_count = len(fileargs["func-list"])
					fileargs["func-list"][func_count-1][1] = keyvalue[1]
				else:
					#we wont parse all values  here, because its too arbitrary to tell
					#rather that is on the client function to ensure that the values are parsed correctly b4 proceeding

					#now we should be able to append it to the current funclist function
					#WARNING: THIS FUNC RETURNS MULTIPLE DIFFERENT TYPES DEPENDING ON ARG VALUE
					# THIS MAY BE THE FIRST LINE REFACTORED!!!
					value = resolveParameter_Unsafe(keyvalue[0], keyvalue[1])
					func_count = len(fileargs["func-list"])
					fileargs["func-list"][func_count-1][2][keyvalue[0]] = value
		if argGroup == "reeb-list":
			reebs = textline.split(PairingDelimiter)
			#note, we also cannot verify pathnames in here because some of the files may not have been generated yet
			#so we have to do that in the main script instead
			if len(reebs) != 2:
				fileargs["error-reason"]="error in "+argfile+", invalid argument pairing in the reeb-list specifier! QUIT"
				fileargs["validation-error"] = True
				return

			fileargs["reeb-list"].append([reebs[0].strip(), reebs[1].strip()])



	def validationCheck():
		if fileargs["model"]["obj"] is "":
			if fileargs["model"]["conn"] is "" or fileargs["model"]["geo"] is "":
				fileargs["error-reason"]="error in "+argfile+", if not using OBJ, BOTH Connectivity and Geomtry files must be defined! QUIT"
				fileargs["validation-error"] = True
				return
			elif fileargs["model"]["conn"] == fileargs["model"]["geo"]:
				fileargs["error-reason"]="error in "+argfile+", Connectivity and Geometry must be separate files! QUIT"
				fileargs["validation-error"] = True
				return
		else:
			if fileargs["model"]["conn"] is not "" or fileargs["model"]["geo"] is  not"":
				fileargs["error-reason"]="error in "+argfile+", Cannot have OBJ and Connectivity+Geometry defined, pick one or the other! QUIT"
				fileargs["validation-error"] = True
				return

	with open(os.path.join(path, argfile), 'r') as f:
		for line in f:
			if fileargs["validation-error"]:
				#we assume error-reason has been set already
				return fileargs
			textline = line.strip()
			if textline.startswith("//"):
				continue
			if textline is "":
				continue
			if textline.endswith(ArgGroupDelimiter):
				currentArgGroup = textline[:-len(ArgGroupDelimiter)]
			else:
				parseArgs(textline, currentArgGroup)
	validationCheck()

	return fileargs